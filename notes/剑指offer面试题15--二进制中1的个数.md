# 剑指offer面试题15--二进制中1的个数

> ```
> 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
> ```

容易想到的思路：该数的各位不断和1相与，然后将该数右移1位，直到所有位都比较过。

```java
public int numberOf1_2(int n) {
  	int count = 0;

  	while (n != 0) {
    	if ((n & 1) == 1) {
      	count++;
    	}
    	n = n >> 1;
  	}
  	return count;
}
```

**注意！上面的代码是错误的！对于非负数来说没有问题，但是当传入负数的时候，由于`>>`是带符号的右移，对于负数来说高位会以1补位，n永远也不会等于9，因此会出现无限循环。**

在Java中右移分两种，一种是上面那样带符号的右移，用`>>`表示，如果数是正数高位以0补位，如果是负数高位以1补位；还有就是无符号的右移，用`>>>`表示，不论正负数，统统高位以0补位。因此只需改动将上述程序的`>>`改成`>>>`即可通过。

## 右移版本

下面的程序才是正确的。

```java
public int numberOf1_2(int n) {
  	int count = 0;

  	while (n != 0) {
    	if ((n & 1) == 1) {
      	count++;
    	}
    	n = n >>> 1;
  	}
  	return count;
}
```

## 左移版本

上面的第一个程序之所以会出现无限循环，是因为我们改变了被输入的数本身。换个角度，我们不改变输入的数，而是通过改变一个变量，那么不管是输入正负数都能得到正确答案。

所以用一个1和输入数的每一位相与，然后将这个1不断**左移**。

```java
public int numberOf1_1(int n) {
  	int count = 0;
  	int flag = 1;
  	while (flag != 0) {
    	if ((n & flag)!= 0) {
      	count++;
    	}
      	// 每次改变的只是这个变量，输入的数始终没有被改变过
    	flag = flag << 1;
  	}
  	return count;
}
```

## 更为巧妙的方法

要想出这样的方法，需要经过一定的分析。将任意数减去1,，有两种情况

- 该数二进制表示的最低位就是1，比如数7，二进制表示为111，此时直接减去1即可；
- 最低位不为1，假设从右往左出现的第一个1，位置为m。则该数减去1后，位置m处的1会变成0，m之后所有的0都会变成1。比如数12，二进制表示为1100，减去1，先找到从右往左数的第一个1，这个位置的1变成0，其后的两个0变成1，即变成了1011。此时，如果将减去1后得到的1011和原来的1100相与，得到1000，相当于是将最右边的那个1变成了0。

也就是说：**把一个整数减去1之后再与原来的整数做位与运算，得到的结果相当于将原整数的二进制表示中最右边的1变成0。**

基于这个推论，写出如下程序。

```java
public int numberOf1(int n) {
  	int count = 0;
	// 只要数不为0，其二进制表示中至少含有一个1
  	while (n != 0) {
      	// 将最右边的1变成0
    	n = (n-1) & n;
      	// 每将一个1变成了0，就计数一次
    	count++;
  	}
  	return count;
}
```

## 相关的题目

利用上面的结果，我们可以解决很多相关的问题。

比如下面的两道

```
1、写一个函数判断一个整数是不是2的正整数次方。

2、输入两个整数m和n，计算需要改变m的二进制表示中的几位才能得到n。比如10的二进制是1010，13的二进制是1101，则需要改变3次。
```

对于问题1：一个整数如果是2的正整数次方，那么这个数必然大于0的，且它的二进制表示中有且只有一位1。所以下面一句就能判断。

```java
public boolean isExponOf2(int n) {
  	return numberOf1(n) == 1;
}
```

对于问题2：先对这两个数求异或，两个数的二进制表示中不同的位就会得到1，相同的位得到0。我要要改变的正是两个数中不同的位，因此，统计异或后二进制中1个个数，即是需要改变的位数。

```java
public int bitNumNeedsToBeChanged(int m, int n) {
  	return numberOf1(m ^ n);
}
```

---

by @sunhaiyu

2017.12.19

