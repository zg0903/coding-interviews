# 剑指offer面试题49--丑数

>   ```
>   把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。
>   ```

穷举法，挨个判断是否是丑数，即使那个数不是丑数也要判断，显然时间复杂度太高。

有没有方法每一步计算只是得到丑数呢？根据丑数的定义，所有丑数都是2、3、5这三个因子的任意搭配的任意多次乘积，比如2x2，2x3, 2x2x3x5等等。那么从1开始，分别乘以2、3、5，得到2、3、5三个丑数，但是这并不是正确的排序，我们知道3、5之间还有个4也是丑数。1之后的下一个丑数，一定是2、3、5其中的一个，显然应该选三者中最小的2，现在丑数集合为{1, 2}且有序，刚才选走的2是1x2得到的，因此下一个和2相乘的丑数应该是1之后的数字2（丑数集合已经有序，直接选择下一个）。现在又得到三个候选的丑数4、3、5，再次选择三者中最小的3，得到当前丑数集合{1, 2, 3}，刚被选走的3由1x3得到，因此下一个要和3相乘的按照丑数集合的顺序应该是2，然后又得到了三个候选的丑数4、6、5，选择最小的4.....不断重复，自始至终只和丑数打交道。

设定三个数t2、t3、t3专门用于分别和2、3、5相乘，某次选择中选走了ti，那么ti从丑数集合中选择下一个数，下次再和i相乘生成一个新的候选丑数，本次没有被选中的，下次继续参与比较。这样能保证下一个丑数一定在三个候选项中，且是三个候选项中最小的那个。

```java
package Chap5;

public class UglyNumber {
    public int uglyNumber(int index) {
        if (index <= 0) return 0;
        int t2 = 0;
        int t3 = 0;
        int t5 = 0;
        int[] res = new int[index];
      	// 第一个丑数为1
        res[0] = 1;
        for (int i = 1; i < index; i++) {
            int m2 = res[t2] * 2;
            int m3 = res[t3] * 3;
            int m5 = res[t5] * 5;
          	// 三个候选中最小的就是下一个丑数
            res[i] = Math.min(m2, Math.min(m3, m5));
          	// 选择某个丑数后ti * i，指针右移从丑数集合中选择下一个丑数和i相乘，注意是三个连续的if，也就是三个if都有可能执行。这种情况发生在三个候选中有多个最小值，指针都要右移，不然会存入重复的丑数
            if (res[i] == m2) t2++;
            if (res[i] == m3) t3++;
            if (res[i] == m5) t5++;
        }
        return res[index - 1];
    }
}

```

---

by @sunhaiyu

2018.1.25

